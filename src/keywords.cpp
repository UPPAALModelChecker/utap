#include "keywords.hpp"

#include "parser.hpp"  // all the tokens

#include <string>
#include <unordered_map>

namespace UTAP {
// clang-format off
    static const auto keyword_map = std::unordered_map<std::string_view, const Keyword>{
            {"const",         Keyword{T_CONST, Syntax::OLD_NEW}},
            {"select",        Keyword{T_SELECT, Syntax::NEW}},
            {"guard",         Keyword{T_GUARD, Syntax::OLD_NEW}},
            {"sync",          Keyword{T_SYNC, Syntax::OLD_NEW}},
            {"assign",        Keyword{T_ASSIGN, Syntax::OLD_NEW}},
            {"probability",   Keyword{T_PROBABILITY, Syntax::OLD_NEW}},
            {"process",       Keyword{T_PROCESS, Syntax::OLD_NEW}},
            {"state",         Keyword{T_STATE, Syntax::OLD_NEW}},
            {"branchpoint",   Keyword{T_BRANCHPOINT, Syntax::OLD_NEW}},
            {"init",          Keyword{T_INIT, Syntax::OLD_NEW}},
            {"trans",         Keyword{T_TRANS, Syntax::OLD_NEW}},
            {"urgent",        Keyword{T_URGENT, Syntax::OLD_NEW}},
            {"commit",        Keyword{T_COMMIT, Syntax::OLD_NEW}},
            {"broadcast",     Keyword{T_BROADCAST, Syntax::OLD_NEW}},
            {"system",        Keyword{T_SYSTEM, Syntax::OLD_NEW_PROPERTY}},
            {"true",          Keyword{T_TRUE, Syntax::OLD_NEW_PROPERTY}},
            {"false",         Keyword{T_FALSE, Syntax::OLD_NEW_PROPERTY}},
            {"and",           Keyword{T_KW_AND, Syntax::OLD_NEW_PROPERTY}},
            {"or",            Keyword{T_KW_OR, Syntax::OLD_NEW_PROPERTY}},
            {"xor",           Keyword{T_KW_XOR, Syntax::NEW}},
            {"not",           Keyword{T_KW_NOT, Syntax::OLD_NEW_PROPERTY}},
            {"imply",         Keyword{T_KW_IMPLY, Syntax::OLD_NEW_PROPERTY}},
            {"for",           Keyword{T_FOR, Syntax::NEW}},
            {"while",         Keyword{T_WHILE, Syntax::NEW}},
            {"do",            Keyword{T_DO, Syntax::NEW}},
            {"if",            Keyword{T_IF, Syntax::NEW}},
            {"else",          Keyword{T_ELSE, Syntax::NEW}},
            {"default",       Keyword{T_DEFAULT, Syntax::NEW}},
            {"return",        Keyword{T_RETURN, Syntax::NEW}},
            {"typedef",       Keyword{T_TYPEDEF, Syntax::NEW}},
            {"struct",        Keyword{T_STRUCT, Syntax::NEW}},
            {"import",        Keyword{T_IMPORT, Syntax::NEW}},
            {"meta",          Keyword{T_META, Syntax::NEW}},
            {"before_update", Keyword{T_BEFORE, Syntax::NEW}},
            {"after_update",  Keyword{T_AFTER, Syntax::NEW}},
            {"progress",      Keyword{T_PROGRESS, Syntax::NEW}},
            {"gantt",         Keyword{T_GANTT, Syntax::NEW}},
            {"assert",        Keyword{T_ASSERT, Syntax::NEW}},
            {"IO",            Keyword{T_IO, Syntax::NEW}},
            {"forall",        Keyword{T_FORALL, Syntax::NEW_PROPERTY}},
            {"exists",        Keyword{T_EXISTS, Syntax::NEW_PROPERTY}},
            {"sum",           Keyword{T_SUM, Syntax::NEW_PROPERTY}},
            {"deadlock",      Keyword{T_DEADLOCK, Syntax::PROPERTY}},
            {"priority",      Keyword{T_PRIORITY, Syntax::OLD_NEW}},
            {"bool",          Keyword{T_BOOL, Syntax::OLD_NEW}},
            {"int",           Keyword{T_INT, Syntax::OLD_NEW_PROPERTY}},
            {"double",        Keyword{T_DOUBLE, Syntax::OLD_NEW}},
            {"string",        Keyword{T_STRING, Syntax::NEW}},
            {"chan",          Keyword{T_CHAN, Syntax::OLD_NEW}},
            {"clock",         Keyword{T_CLOCK, Syntax::OLD_NEW}},
            {"void",          Keyword{T_VOID, Syntax::OLD_NEW}},
            {"scalar",        Keyword{T_SCALAR, Syntax::OLD_NEW_PROPERTY}},
            {"control",       Keyword{T_CONTROL, Syntax::PROPERTY_TIGA}},
            {"control_t",     Keyword{T_CONTROL_T, Syntax::PROPERTY_TIGA}},
            {"simulation",    Keyword{T_SIMULATION, Syntax::PROPERTY_TIGA}},
            {"minE",          Keyword{T_MINEXP, Syntax::PROPERTY_TIGA}},
            {"loadStrategy",  Keyword{T_LOAD_STRAT, Syntax::PROPERTY_TIGA}},
            {"saveStrategy",  Keyword{T_SAVE_STRAT, Syntax::PROPERTY_TIGA}},
            {"maxE",          Keyword{T_MAXEXP, Syntax::PROPERTY_TIGA}},
            {"minPr",         Keyword{T_MINPR, Syntax::PROPERTY_TIGA}},
            {"maxPr",         Keyword{T_MAXPR, Syntax::PROPERTY_TIGA}},
            {"under",         Keyword{T_SUBJECT, Syntax::PROPERTY_TIGA}},
            {"imitate",       Keyword{T_IMITATE, Syntax::PROPERTY_TIGA}},
            {"strategy",      Keyword{T_STRATEGY, Syntax::PROPERTY_TIGA}},
            {"simulate",      Keyword{T_SIMULATE, Syntax::PROPERTY}},
            {"sat",           Keyword{T_SCENARIO, Syntax::PROPERTY}},
            {"inf",           Keyword{T_INF, Syntax::PROPERTY}},
            {"sup",           Keyword{T_SUP, Syntax::PROPERTY}},
            {"bounds",        Keyword{T_BOUNDS, Syntax::PROPERTY}},
            {"Pmax",          Keyword{T_PMAX, Syntax::PROPERTY_PROB}},
            {"Pr",            Keyword{T_PROBA, Syntax::PROPERTY}},
            {"X",             Keyword{T_MITL_NEXT, Syntax::PROPERTY}},
            {"abs",           Keyword{T_ABS, Syntax::NEW_PROPERTY}},
            {"fabs",          Keyword{T_FABS, Syntax::NEW_PROPERTY}},
            {"fmod",          Keyword{T_FMOD, Syntax::NEW_PROPERTY}},
            {"fma",           Keyword{T_FMA, Syntax::NEW_PROPERTY}},
            {"fmax",          Keyword{T_FMAX, Syntax::NEW_PROPERTY}},
            {"fmin",          Keyword{T_FMIN, Syntax::NEW_PROPERTY}},
            {"fdim",          Keyword{T_FDIM, Syntax::NEW_PROPERTY}},
            {"exp",           Keyword{T_EXP, Syntax::NEW_PROPERTY}},
            {"exp2",          Keyword{T_EXP2, Syntax::NEW_PROPERTY}},
            {"expm1",         Keyword{T_EXPM1, Syntax::NEW_PROPERTY}},
            {"ln",            Keyword{T_LN, Syntax::NEW_PROPERTY}},
            {"log",           Keyword{T_LOG, Syntax::NEW_PROPERTY}},
            {"log10",         Keyword{T_LOG10, Syntax::NEW_PROPERTY}},
            {"log2",          Keyword{T_LOG2, Syntax::NEW_PROPERTY}},
            {"log1p",         Keyword{T_LOG1P, Syntax::NEW_PROPERTY}},
            {"pow",           Keyword{T_POW, Syntax::NEW_PROPERTY}},
            {"sqrt",          Keyword{T_SQRT, Syntax::NEW_PROPERTY}},
            {"cbrt",          Keyword{T_CBRT, Syntax::NEW_PROPERTY}},
            {"hypot",         Keyword{T_HYPOT, Syntax::NEW_PROPERTY}},
            {"sin",           Keyword{T_SIN, Syntax::NEW_PROPERTY}},
            {"cos",           Keyword{T_COS, Syntax::NEW_PROPERTY}},
            {"tan",           Keyword{T_TAN, Syntax::NEW_PROPERTY}},
            {"asin",          Keyword{T_ASIN, Syntax::NEW_PROPERTY}},
            {"acos",          Keyword{T_ACOS, Syntax::NEW_PROPERTY}},
            {"atan",          Keyword{T_ATAN, Syntax::NEW_PROPERTY}},
            {"atan2",         Keyword{T_ATAN2, Syntax::NEW_PROPERTY}},
            {"sinh",          Keyword{T_SINH, Syntax::NEW_PROPERTY}},
            {"cosh",          Keyword{T_COSH, Syntax::NEW_PROPERTY}},
            {"tanh",          Keyword{T_TANH, Syntax::NEW_PROPERTY}},
            {"asinh",         Keyword{T_ASINH, Syntax::NEW_PROPERTY}},
            {"acosh",         Keyword{T_ACOSH, Syntax::NEW_PROPERTY}},
            {"atanh",         Keyword{T_ATANH, Syntax::NEW_PROPERTY}},
            {"erf",           Keyword{T_ERF, Syntax::NEW_PROPERTY}},
            {"erfc",          Keyword{T_ERFC, Syntax::NEW_PROPERTY}},
            {"tgamma",        Keyword{T_TGAMMA, Syntax::NEW_PROPERTY}},
            {"lgamma",        Keyword{T_LGAMMA, Syntax::NEW_PROPERTY}},
            {"ceil",          Keyword{T_CEIL, Syntax::NEW_PROPERTY}},
            {"floor",         Keyword{T_FLOOR, Syntax::NEW_PROPERTY}},
            {"trunc",         Keyword{T_TRUNC, Syntax::NEW_PROPERTY}},
            {"round",         Keyword{T_ROUND, Syntax::NEW_PROPERTY}},
            {"fint",          Keyword{T_FINT, Syntax::NEW_PROPERTY}},
            {"ldexp",         Keyword{T_LDEXP, Syntax::NEW_PROPERTY}},
            {"ilogb",         Keyword{T_ILOGB, Syntax::NEW_PROPERTY}},
            {"logb",          Keyword{T_LOGB, Syntax::NEW_PROPERTY}},
            {"nextafter",     Keyword{T_NEXTAFTER, Syntax::NEW_PROPERTY}},
            {"copysign",      Keyword{T_COPYSIGN, Syntax::NEW_PROPERTY}},
            {"fpclassify",    Keyword{T_FPCLASSIFY, Syntax::NEW_PROPERTY}},
            {"isfinite",      Keyword{T_ISFINITE, Syntax::NEW_PROPERTY}},
            {"isinf",         Keyword{T_ISINF, Syntax::NEW_PROPERTY}},
            {"isnan",         Keyword{T_ISNAN, Syntax::NEW_PROPERTY}},
            {"isnormal",      Keyword{T_ISNORMAL, Syntax::NEW_PROPERTY}},
            {"signbit",       Keyword{T_SIGNBIT, Syntax::NEW_PROPERTY}},
            {"isunordered",   Keyword{T_ISUNORDERED, Syntax::NEW_PROPERTY}},
            {"random",        Keyword{T_RANDOM, Syntax::NEW_PROPERTY}},
			{"random_arcsine",Keyword{T_RANDOM_ARCSINE, Syntax::NEW_PROPERTY}},
			{"random_beta",   Keyword{T_RANDOM_BETA, Syntax::NEW_PROPERTY}},
			{"random_gamma",  Keyword{T_RANDOM_GAMMA, Syntax::NEW_PROPERTY}},
			{"random_normal", Keyword{T_RANDOM_NORMAL, Syntax::NEW_PROPERTY}},
			{"random_poisson",Keyword{T_RANDOM_POISSON, Syntax::NEW_PROPERTY}},
			{"random_tri",    Keyword{T_RANDOM_TRI, Syntax::NEW_PROPERTY}},
			{"random_weibull",Keyword{T_RANDOM_WEIBULL, Syntax::NEW_PROPERTY}},
            {"hybrid",        Keyword{T_HYBRID, Syntax::NEW}},
            {"dynamic",       Keyword{T_DYNAMIC, Syntax::NEW}},
            {"spawn",         Keyword{T_SPAWN, Syntax::NEW}},
            {"exit",          Keyword{T_EXIT, Syntax::NEW}},
            {"numOf",         Keyword{T_NUMOF, Syntax::PROPERTY}},
            {"foreach",       Keyword{T_FOREACH, Syntax::PROPERTY}},
            {"query",         Keyword{T_QUERY, Syntax::NEW}},
            {"location",      Keyword{T_LOCATION, Syntax::NEW}},
    };
// clang-format on

const Keyword* find_keyword(std::string_view word)
{
    const auto keyword = keyword_map.find(word);
    if (keyword == std::end(keyword_map))
        return nullptr;
    return &keyword->second;
}

bool is_keyword(std::string_view word, Syntax syntax)
{
    const auto* keyword = find_keyword(word);
    if (keyword != nullptr)
        return (keyword->syntax & syntax) != Syntax::NONE;
    else
        return false;
}
}  // namespace UTAP
