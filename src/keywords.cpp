#include "keywords.hpp"

#include "parser.hpp"  // all the tokens

#include <string>
#include <unordered_map>

namespace UTAP
{
    // clang-format off
    static const auto keyword_map = std::unordered_map<std::string_view, const Keyword>{
            {"const",         Keyword{T_CONST, syntax_t::OLD_NEW}},
            {"select",        Keyword{T_SELECT, syntax_t::NEW}},
            {"guard",         Keyword{T_GUARD, syntax_t::OLD_NEW}},
            {"sync",          Keyword{T_SYNC, syntax_t::OLD_NEW}},
            {"assign",        Keyword{T_ASSIGN, syntax_t::OLD_NEW}},
            {"probability",   Keyword{T_PROBABILITY, syntax_t::OLD_NEW}},
            {"process",       Keyword{T_PROCESS, syntax_t::OLD_NEW}},
            {"state",         Keyword{T_STATE, syntax_t::OLD_NEW}},
            {"branchpoint",   Keyword{T_BRANCHPOINT, syntax_t::OLD_NEW}},
            {"init",          Keyword{T_INIT, syntax_t::OLD_NEW}},
            {"trans",         Keyword{T_TRANS, syntax_t::OLD_NEW}},
            {"urgent",        Keyword{T_URGENT, syntax_t::OLD_NEW}},
            {"commit",        Keyword{T_COMMIT, syntax_t::OLD_NEW}},
            {"broadcast",     Keyword{T_BROADCAST, syntax_t::OLD_NEW}},
            {"system",        Keyword{T_SYSTEM, syntax_t::OLD_NEW_PROPERTY}},
            {"true",          Keyword{T_TRUE, syntax_t::OLD_NEW_PROPERTY}},
            {"false",         Keyword{T_FALSE, syntax_t::OLD_NEW_PROPERTY}},
            {"and",           Keyword{T_KW_AND, syntax_t::OLD_NEW_PROPERTY}},
            {"or",            Keyword{T_KW_OR, syntax_t::OLD_NEW_PROPERTY}},
            {"xor",           Keyword{T_KW_XOR, syntax_t::NEW}},
            {"not",           Keyword{T_KW_NOT, syntax_t::OLD_NEW_PROPERTY}},
            {"imply",         Keyword{T_KW_IMPLY, syntax_t::OLD_NEW_PROPERTY}},
            {"for",           Keyword{T_FOR, syntax_t::NEW}},
            {"while",         Keyword{T_WHILE, syntax_t::NEW}},
            {"do",            Keyword{T_DO, syntax_t::NEW}},
            {"if",            Keyword{T_IF, syntax_t::NEW}},
            {"else",          Keyword{T_ELSE, syntax_t::NEW}},
            {"default",       Keyword{T_DEFAULT, syntax_t::NEW}},
            {"return",        Keyword{T_RETURN, syntax_t::NEW}},
            {"typedef",       Keyword{T_TYPEDEF, syntax_t::NEW}},
            {"struct",        Keyword{T_STRUCT, syntax_t::NEW}},
            {"import",        Keyword{T_IMPORT, syntax_t::NEW}},
            {"meta",          Keyword{T_META, syntax_t::NEW}},
            {"before_update", Keyword{T_BEFORE, syntax_t::NEW}},
            {"after_update",  Keyword{T_AFTER, syntax_t::NEW}},
            {"progress",      Keyword{T_PROGRESS, syntax_t::NEW}},
            {"gantt",         Keyword{T_GANTT, syntax_t::NEW}},
            {"assert",        Keyword{T_ASSERT, syntax_t::NEW}},
            {"IO",            Keyword{T_IO, syntax_t::NEW}},
            {"forall",        Keyword{T_FORALL, syntax_t::NEW_PROPERTY}},
            {"exists",        Keyword{T_EXISTS, syntax_t::NEW_PROPERTY}},
            {"sum",           Keyword{T_SUM, syntax_t::NEW_PROPERTY}},
            {"deadlock",      Keyword{T_DEADLOCK, syntax_t::PROPERTY}},
            {"priority",      Keyword{T_PRIORITY, syntax_t::OLD_NEW}},
            {"bool",          Keyword{T_BOOL, syntax_t::OLD_NEW}},
            {"int",           Keyword{T_INT, syntax_t::OLD_NEW_PROPERTY}},
            {"double",        Keyword{T_DOUBLE, syntax_t::OLD_NEW}},
            {"string",        Keyword{T_STRING, syntax_t::NEW}},
            {"chan",          Keyword{T_CHAN, syntax_t::OLD_NEW}},
            {"clock",         Keyword{T_CLOCK, syntax_t::OLD_NEW}},
            {"void",          Keyword{T_VOID, syntax_t::OLD_NEW}},
            {"scalar",        Keyword{T_SCALAR, syntax_t::OLD_NEW_PROPERTY}},
            {"control",       Keyword{T_CONTROL, syntax_t::PROPERTY_TIGA}},
            {"control_t",     Keyword{T_CONTROL_T, syntax_t::PROPERTY_TIGA}},
            {"simulation",    Keyword{T_SIMULATION, syntax_t::PROPERTY_TIGA}},
            {"minE",          Keyword{T_MINEXP, syntax_t::PROPERTY_TIGA}},
            {"loadStrategy",  Keyword{T_LOAD_STRAT, syntax_t::PROPERTY_TIGA}},
            {"saveStrategy",  Keyword{T_SAVE_STRAT, syntax_t::PROPERTY_TIGA}},
            {"maxE",          Keyword{T_MAXEXP, syntax_t::PROPERTY_TIGA}},
            {"minPr",         Keyword{T_MINPR, syntax_t::PROPERTY_TIGA}},
            {"maxPr",         Keyword{T_MAXPR, syntax_t::PROPERTY_TIGA}},
            {"under",         Keyword{T_SUBJECT, syntax_t::PROPERTY_TIGA}},
            {"imitate",       Keyword{T_IMITATE, syntax_t::PROPERTY_TIGA}},
            {"strategy",      Keyword{T_STRATEGY, syntax_t::PROPERTY_TIGA}},
            {"simulate",      Keyword{T_SIMULATE, syntax_t::PROPERTY}},
            {"sat",           Keyword{T_SCENARIO, syntax_t::PROPERTY}},
            {"inf",           Keyword{T_INF, syntax_t::PROPERTY}},
            {"sup",           Keyword{T_SUP, syntax_t::PROPERTY}},
            {"Pmax",          Keyword{T_PMAX, syntax_t::PROPERTY_PROB}},
            {"Pr",            Keyword{T_PROBA, syntax_t::PROPERTY}},
            {"X",             Keyword{T_MITL_NEXT, syntax_t::PROPERTY}},
            {"abs",           Keyword{T_ABS, syntax_t::NEW_PROPERTY}},
            {"fabs",          Keyword{T_FABS, syntax_t::NEW_PROPERTY}},
            {"fmod",          Keyword{T_FMOD, syntax_t::NEW_PROPERTY}},
            {"fma",           Keyword{T_FMA, syntax_t::NEW_PROPERTY}},
            {"fmax",          Keyword{T_FMAX, syntax_t::NEW_PROPERTY}},
            {"fmin",          Keyword{T_FMIN, syntax_t::NEW_PROPERTY}},
            {"fdim",          Keyword{T_FDIM, syntax_t::NEW_PROPERTY}},
            {"exp",           Keyword{T_EXP, syntax_t::NEW_PROPERTY}},
            {"exp2",          Keyword{T_EXP2, syntax_t::NEW_PROPERTY}},
            {"expm1",         Keyword{T_EXPM1, syntax_t::NEW_PROPERTY}},
            {"ln",            Keyword{T_LN, syntax_t::NEW_PROPERTY}},
            {"log",           Keyword{T_LOG, syntax_t::NEW_PROPERTY}},
            {"log10",         Keyword{T_LOG10, syntax_t::NEW_PROPERTY}},
            {"log2",          Keyword{T_LOG2, syntax_t::NEW_PROPERTY}},
            {"log1p",         Keyword{T_LOG1P, syntax_t::NEW_PROPERTY}},
            {"pow",           Keyword{T_POW, syntax_t::NEW_PROPERTY}},
            {"sqrt",          Keyword{T_SQRT, syntax_t::NEW_PROPERTY}},
            {"cbrt",          Keyword{T_CBRT, syntax_t::NEW_PROPERTY}},
            {"hypot",         Keyword{T_HYPOT, syntax_t::NEW_PROPERTY}},
            {"sin",           Keyword{T_SIN, syntax_t::NEW_PROPERTY}},
            {"cos",           Keyword{T_COS, syntax_t::NEW_PROPERTY}},
            {"tan",           Keyword{T_TAN, syntax_t::NEW_PROPERTY}},
            {"asin",          Keyword{T_ASIN, syntax_t::NEW_PROPERTY}},
            {"acos",          Keyword{T_ACOS, syntax_t::NEW_PROPERTY}},
            {"atan",          Keyword{T_ATAN, syntax_t::NEW_PROPERTY}},
            {"atan2",         Keyword{T_ATAN2, syntax_t::NEW_PROPERTY}},
            {"sinh",          Keyword{T_SINH, syntax_t::NEW_PROPERTY}},
            {"cosh",          Keyword{T_COSH, syntax_t::NEW_PROPERTY}},
            {"tanh",          Keyword{T_TANH, syntax_t::NEW_PROPERTY}},
            {"asinh",         Keyword{T_ASINH, syntax_t::NEW_PROPERTY}},
            {"acosh",         Keyword{T_ACOSH, syntax_t::NEW_PROPERTY}},
            {"atanh",         Keyword{T_ATANH, syntax_t::NEW_PROPERTY}},
            {"erf",           Keyword{T_ERF, syntax_t::NEW_PROPERTY}},
            {"erfc",          Keyword{T_ERFC, syntax_t::NEW_PROPERTY}},
            {"tgamma",        Keyword{T_TGAMMA, syntax_t::NEW_PROPERTY}},
            {"lgamma",        Keyword{T_LGAMMA, syntax_t::NEW_PROPERTY}},
            {"ceil",          Keyword{T_CEIL, syntax_t::NEW_PROPERTY}},
            {"floor",         Keyword{T_FLOOR, syntax_t::NEW_PROPERTY}},
            {"trunc",         Keyword{T_TRUNC, syntax_t::NEW_PROPERTY}},
            {"round",         Keyword{T_ROUND, syntax_t::NEW_PROPERTY}},
            {"fint",          Keyword{T_FINT, syntax_t::NEW_PROPERTY}},
            {"ldexp",         Keyword{T_LDEXP, syntax_t::NEW_PROPERTY}},
            {"ilogb",         Keyword{T_ILOGB, syntax_t::NEW_PROPERTY}},
            {"logb",          Keyword{T_LOGB, syntax_t::NEW_PROPERTY}},
            {"nextafter",     Keyword{T_NEXTAFTER, syntax_t::NEW_PROPERTY}},
            {"copysign",      Keyword{T_COPYSIGN, syntax_t::NEW_PROPERTY}},
            {"fpclassify",    Keyword{T_FPCLASSIFY, syntax_t::NEW_PROPERTY}},
            {"isfinite",      Keyword{T_ISFINITE, syntax_t::NEW_PROPERTY}},
            {"isinf",         Keyword{T_ISINF, syntax_t::NEW_PROPERTY}},
            {"isnan",         Keyword{T_ISNAN, syntax_t::NEW_PROPERTY}},
            {"isnormal",      Keyword{T_ISNORMAL, syntax_t::NEW_PROPERTY}},
            {"signbit",       Keyword{T_SIGNBIT, syntax_t::NEW_PROPERTY}},
            {"isunordered",   Keyword{T_ISUNORDERED, syntax_t::NEW_PROPERTY}},
            {"random",        Keyword{T_RANDOM, syntax_t::NEW_PROPERTY}},
			{"random_arcsine",Keyword{T_RANDOM_ARCSINE, syntax_t::NEW_PROPERTY}},
			{"random_beta",   Keyword{T_RANDOM_BETA, syntax_t::NEW_PROPERTY}},
			{"random_gamma",  Keyword{T_RANDOM_GAMMA, syntax_t::NEW_PROPERTY}},
			{"random_normal", Keyword{T_RANDOM_NORMAL, syntax_t::NEW_PROPERTY}},
			{"random_poisson",Keyword{T_RANDOM_POISSON, syntax_t::NEW_PROPERTY}},
			{"random_tri",    Keyword{T_RANDOM_TRI, syntax_t::NEW_PROPERTY}},
			{"random_weibull",Keyword{T_RANDOM_WEIBULL, syntax_t::NEW_PROPERTY}},
            {"hybrid",        Keyword{T_HYBRID, syntax_t::NEW}},
            {"dynamic",       Keyword{T_DYNAMIC, syntax_t::NEW}},
            {"spawn",         Keyword{T_SPAWN, syntax_t::NEW}},
            {"exit",          Keyword{T_EXIT, syntax_t::NEW}},
            {"numOf",         Keyword{T_NUMOF, syntax_t::PROPERTY}},
            {"foreach",       Keyword{T_FOREACH, syntax_t::PROPERTY}},
            {"query",         Keyword{T_QUERY, syntax_t::NEW}},
            {"location",      Keyword{T_LOCATION, syntax_t::NEW}},
    };
    // clang-format on

    const Keyword* find_keyword(std::string_view word)
    {
        const auto keyword = keyword_map.find(word);
        if (keyword == std::end(keyword_map))
            return nullptr;
        return &keyword->second;
    }

    bool is_keyword(std::string_view word, syntax_t syntax)
    {
        const auto* keyword = find_keyword(word);
        if (keyword)
            return keyword->syntax & syntax;
        else
            return false;
    }
}  // namespace UTAP
