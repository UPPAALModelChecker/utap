// -*- mode: C++; c-file-style: "stroustrup"; c-basic-offset: 4; indent-tabs-mode: nil; -*-

/* libutap - Uppaal Timed Automata Parser.
   Copyright (C) 2020-2024 Aalborg University.
   Copyright (C) 2002-2006 Uppsala University and Aalborg University.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License
   as published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
   USA
*/

#ifndef UTAP_DOCUMENT_HH
#define UTAP_DOCUMENT_HH

#include "utap/Library.hpp"
#include "utap/expression.hpp"
#include "utap/position.hpp"
#include "utap/symbols.hpp"

#include <algorithm>  // find
#include <deque>
#include <list>
#include <map>
#include <optional>
#include <vector>

namespace UTAP {

/**
 * Classes used to represent model document (Abstract Syntax Tree).
 */

/// Describes supported analysis methods for the given document
struct SupportedMethods
{
    bool symbolic{true};
    bool stochastic{true};
    bool concrete{true};
};

/// Adds str() method calling Item::print(std::ostream&) to produce a string representation
template <typename Item>
struct Stringify
{
    std::string str() const;
};

/// Adds str(indent) method calling Item::print(std::ostream&, indent) to produce a string representation
template <typename Item>
struct StringifyIndent : Stringify<Item>
{
    std::string str(const std::string& indent) const;
};

/** Base type for variables, clocks, etc.  The user data of the
    corresponding Symbol points to this structure,
    i.e. v.uid.get_data() is a pointer to v.
*/
struct Variable : Stringify<Variable>
{
    Symbol uid;                                ///< The symbol of the variable
    Expression init;                           ///< The initializer
    std::ostream& print(std::ostream&) const;  ///< outputs a textual representation
};

/** Information about a location.
    The symbol's user data points to this structure, i.e.
    s.uid.get_data() is a pointer to s. Notice that the rate list
    is generated by the type checker; until then the rate
    expressions are part of the invariant.
*/
struct Location : Stringify<Location>
{
    Symbol uid;            ///< The symbol of the location
    Expression name;       ///< TODO: the location name with its position
    Expression invariant;  ///< The invariant
    Expression exp_rate;   ///< the exponential rate controlling the speed of leaving the location
    Expression cost_rate;  ///< cost rate/derivative expression
    int32_t nr;            ///< Location number in a template
    std::ostream& print(std::ostream&) const;
};

/** Information about a branchpoint.
    Branchpoints may be used in construction of edges with the
    same source, guard and synchronisation channel.
    They are not present after compilation of a model.
 */
struct Branchpoint
{
    Symbol uid;
    int32_t bpNr;
};

/** Information about an edge.  Edges have a source (src) and a
    destination (dst), which may be locations or branchpoints.
    The unused of these pointers should be set to nullptr.
    The guard, synchronisation and assignment are stored as
    expressions.
*/
struct Edge : Stringify<Edge>
{
    int nr;        ///< Placement in input file
    bool control;  ///< Controllable (true/false)
    std::string actname;
    Location* src{nullptr};             ///< Pointer to source location
    Branchpoint* srcb{nullptr};         ///< Pointer to source branchpoint
    Location* dst{nullptr};             ///< Pointer to destination location
    Branchpoint* dstb{nullptr};         ///< Pointer to destination branchpoint
    Frame select;                       ///< Frame for non-deterministic select
    Expression guard;                   ///< The guard
    Expression assign;                  ///< The assignment
    Expression sync;                    ///< The synchronisation
    Expression prob;                    ///< Probability for probabilistic edges.
    std::vector<int32_t> selectValues;  ///< The select values, if any
    std::ostream& print(std::ostream&) const;
};

class BlockStatement;  // Forward declaration

/** Information about a function. The symbol's user data points to
    this structure, i.e. f.uid.get_data() is a pointer to f.
*/
struct Function : Stringify<Function>
{
    Symbol uid;                                     ///< The symbol of the function.
    std::set<Symbol> changes{};                     ///< Variables changed by this function.
    std::set<Symbol> depends{};                     ///< Variables the function depends on.
    std::list<Variable> variables{};                ///< Local variables. List is used for stable pointers.
    std::unique_ptr<BlockStatement> body{nullptr};  ///< Pointer to the block.
    Function() = default;
    std::ostream& print(std::ostream& os) const;  ///< textual representation, used to write the XML file
};

/// Progress meassure expressions for sweep-line method (state-space memory reuse)
struct Progress
{
    Expression guard;
    Expression measure;
    Progress(Expression guard, Expression measure): guard{std::move(guard)}, measure{std::move(measure)} {}
};

/// I/O declarations
struct IODecl
{
    std::string instanceName;
    std::vector<Expression> param;
    std::list<Expression> inputs, outputs, csp;
};

/**
 * Gantt map bool expr -> int expr that
 * can be expanded.
 */
struct GanttMap
{
    Frame parameters;
    Expression predicate;
    Expression mapping;
    GanttMap(Frame param, Expression pred, Expression m):
        parameters{std::move(param)}, predicate{std::move(pred)}, mapping{std::move(m)}
    {}
};

/// Gantt chart Entry.
struct GanttEntry
{
    std::string name;  ///< The name
    Frame parameters;  ///< The select parameters
    std::list<GanttMap> mapping;
    explicit GanttEntry(std::string_view name): name{name} {}
};

/**
 * Structure holding declarations of various types. Used by
 * templates and block statements.
 */
struct Template;
struct Declarations : Stringify<Declarations>
{
    Frame frame;
    std::list<Variable> variables;  ///< Variables. List is used for stable pointers.
    std::list<Function> functions;  ///< Functions
    std::list<Progress> progress;   ///< Progress measures
    std::list<IODecl> iodecl;
    std::list<GanttEntry> ganttChart;

    /// Add function declaration.
    bool add_function(Type type, std::string_view name, position_t, Function*&);
    /// The following methods are used to write the declarations in an XML file
    std::string str(bool global) const;
    std::ostream& print(std::ostream&, bool global = false) const;
    std::ostream& print_constants(std::ostream&) const;
    std::ostream& print_typedefs(std::ostream&) const;
    std::ostream& print_variables(std::ostream&, bool global) const;
    std::ostream& print_functions(std::ostream&) const;
};

struct LSCInstanceLine;  // to be defined later

/// Common members among LSC elements */
struct LSCElement
{
    uint32_t nr;  ///< Placement in input file
    int location{-1};
    bool is_in_prechart{false};
    explicit LSCElement(uint32_t nr): nr{nr} {}
    uint32_t get_nr() const { return nr; }
};

/** Information about a message. Messages have a source (src) and a
 * destination (dst) instance lines. The label is
 * stored as an expression.
 */
struct LSCMessage : LSCElement
{
    LSCInstanceLine* src{nullptr};  ///< Pointer to source instance line
    LSCInstanceLine* dst{nullptr};  ///< Pointer to destination instance line
    Expression label;               ///< The label
    explicit LSCMessage(uint32_t nr): LSCElement{nr} {}
};
/** Information about a condition. Conditions have an anchor instance lines.
 * The label is stored as an expression.
 */
struct LSCCondition : LSCElement
{
    std::vector<LSCInstanceLine*> anchors{};  ///< Pointer to anchor instance lines
    Expression label;                         ///< The label
    bool isHot{false};
    explicit LSCCondition(uint32_t nr): LSCElement{nr} {}
};

/** Information about an update. Update have an anchor instance line.
 * The label is stored as an expression.
 */
struct LSCUpdate : LSCElement
{
    LSCInstanceLine* anchor{nullptr};  ///< Pointer to anchor instance line
    Expression label;                  ///< The label
    explicit LSCUpdate(uint32_t nr): LSCElement{nr} {}
};

struct LSCSimRegion : Stringify<LSCSimRegion>
{
    uint32_t nr{};
    LSCMessage* message{nullptr};      // May be empty
    LSCCondition* condition{nullptr};  // May be empty
    LSCUpdate* update{nullptr};        // May be empty

    int get_loc() const;
    bool is_in_prechart() const;

    std::ostream& print(std::ostream&) const;
    bool has_message() const { return message != nullptr; }
    bool has_condition() const { return condition != nullptr; }
    bool has_update() const { return update != nullptr; }
    void set_message(std::deque<LSCMessage>& messages, uint32_t nr);
    void set_condition(std::deque<LSCCondition>& conditions, uint32_t nr);
    void set_update(std::deque<LSCUpdate>& updates, uint32_t nr);
};

struct LSCSimRegionComparator
{
    bool operator()(const LSCSimRegion& x, const LSCSimRegion& y) const { return (x.get_loc() < y.get_loc()); }
};

struct LSCCut : Stringify<LSCCut>
{
    int nr;
    std::vector<LSCSimRegion> simregions{};  // unordered
    explicit LSCCut(int number): nr{number} {};
    void add(const LSCSimRegion& s) { simregions.push_back(s); };
    void erase(const LSCSimRegion& s);
    bool contains(const LSCSimRegion& s) const;

    /**
     * returns true if the cut is in the prechart,
     * given one of the following simregions.
     * if one of the following simregions is not in the prechart,
     * then all following simregions aren't in the prechart (because of the
     * construction of the partial order),
     * and the cut is not in the prechart (but may contain only simregions
     * that are in the prechart, if it is the limit between the prechart
     * and the mainchart)
     */
    bool is_in_prechart(const LSCSimRegion& fSimregion) const;
    bool is_in_prechart() const;

    bool equals(const LSCCut& y) const;
    std::ostream& print(std::ostream&) const;
};

/**
 * Partial instance of a template. Every template is also a
 * partial instance of itself and therefore Template is derived
 * from Instance. A complete instance is just a partial instance
 * without any parameters.
 *
 * Even though it is possible to make partial instances of partial
 * instances, they are not represented hierarchically: All
 * parameters and arguments are merged into this one
 * struct. Therefore \a parameters contains both bound and unbound
 * symbols: Unbound symbols are parameters of this instance. Bound
 * symbols are inherited from another instance. Symbols in \a
 * parameters are ordered such that unbound symbols are listed
 * first, i.e., uid.get_type().size() == parameters.get_size().
 *
 * \a mapping binds parameters to expressions.
 *
 * \a arguments is the number of arguments given by the partial
 * instance. The first \a arguments bound symbols of \a parameters
 * are the corresponding parameters. For templates, \a arguments
 * is obviously 0.
 *
 * Restricted variables are those that are used either directly or
 * indirectly in the definition of array sizes. Any restricted
 * parameters have restriction on the kind of arguments they
 * accept (they must not depend on any free process parameters).
 *
 * If i is an instance, then i.uid.get_data() == i.
 */
struct Instance
{
    Symbol uid{};                          ///< The name
    Frame parameters{};                    ///< The parameters
    std::map<Symbol, Expression> mapping;  ///< The parameter to argument mapping
    uint32_t arguments{0};
    uint32_t unbound{0};  ///< The number of unbound parameters
    struct Template* templ{nullptr};
    std::set<Symbol> restricted;  ///< Restricted variables

    std::ostream& print_mapping(std::ostream&) const;
    std::ostream& print_parameters(std::ostream&) const;
    std::ostream& print_arguments(std::ostream&) const;
    std::string mapping_str() const;
    std::string parameters_str() const;
    std::string arguments_str() const;
};

/// Information about an instance line.
struct LSCInstanceLine : public Instance
{
    uint32_t instance_nr;  ///< LSCInstanceLine number in template
    std::vector<LSCSimRegion> get_simregions(const std::vector<LSCSimRegion>& simregions);
    void add_parameters(Instance& inst, Frame params, const std::vector<Expression>& arguments);
};

struct Template : public Instance, Declarations
{
    Symbol init{};                         ///< The initial location
    Frame template_set{};                  ///< Template set decls
    std::deque<Location> locations;        ///< Locations
    std::deque<Branchpoint> branchpoints;  ///< Branchpoints
    std::deque<Edge> edges;                ///< Edges
    std::vector<Expression> dynamic_evals;
    bool is_TA{true};
    bool is_instantiated{false};  ///< Is the template used in the system

    size_t add_dynamic_eval(Expression t)
    {
        dynamic_evals.push_back(std::move(t));
        return dynamic_evals.size() - 1;
    }

    std::vector<Expression>& get_dynamic_eval() { return dynamic_evals; }

    /// Add another location to template.
    Location& add_location(std::string_view name, Expression inv, Expression er, position_t pos);

    /// Add another branchpoint to template.
    Branchpoint& add_branchpoint(std::string_view, position_t);

    /// Add edge to template.
    Edge& add_edge(Symbol src, Symbol dst, bool type, std::string_view actname);

    std::deque<LSCInstanceLine> instances;  ///< Instance Lines
    std::deque<LSCMessage> messages;        ///< Messages
    std::deque<LSCUpdate> updates;          ///< Updates
    std::deque<LSCCondition> conditions;    ///< Conditions
    std::string type;
    std::string mode;
    bool has_prechart{false};
    bool dynamic{false};
    int dyn_index{0};
    bool is_defined{false};

    /// Add another instance line to template.
    LSCInstanceLine& add_instance_line();

    /// Add message to template.
    LSCMessage& add_message(Symbol src, Symbol dst, int loc, bool pch);

    /// Add condition to template.
    LSCCondition& add_condition(std::vector<Symbol> anchors, int loc, bool pch, bool isHot);

    /// Add update to template.
    LSCUpdate& add_update(Symbol anchor, int loc, bool pch);

    bool is_invariant() const;  // type of the LSC

    /// gets the simregions from the LSC scenario
    std::vector<LSCSimRegion> get_simregions();

    /// returns the condition on the given instance, at y location
    bool get_condition(LSCInstanceLine& instance, int y, LSCCondition*& simCondition);

    /// returns the update on the given instance at y location
    bool get_update(LSCInstanceLine& instance, int y, LSCUpdate*& simUpdate);

    /// returns the first update on one of the given instances, at y location
    bool get_update(std::vector<LSCInstanceLine*>& instances, int y, LSCUpdate*& simUpdate);
};

/**
 * Channel priority information. Expressions must evaluate to
 * a channel or an array of channels.
 */
struct ChanPriority : Stringify<ChanPriority>
{
    using Entry = std::pair<char, Expression>;
    using Tail = std::list<Entry>;

    Expression head;  //!< First expression in priority declaration
    Tail tail;        //!< Pairs: separator and channel expressions

    std::ostream& print(std::ostream&) const;
};

/// Denotes the kind of result is to be expected from a query
enum class ExpectationKind { Symbolic, Probability, NumericValue, _ErrorValue };

/// Status of the query
enum class QueryStatus { True, False, MaybeTrue, MaybeFalse, Unknown };

/// Verification option
struct Option
{
    std::string name;
    std::string value;
    Option(std::string name, std::string value): name{std::move(name)}, value{std::move(value)} {}
};

/// The kind of resource used for verifying a query
enum class ResourceKind { Time, Memory };

/// Describes the amount of specific resource used for verification
struct Resource
{
    std::string name;
    std::string value;
    std::optional<std::string> unit;
    Resource(std::string name, std::string value, std::optional<std::string> unit):
        name{std::move(name)}, value{std::move(name)}, unit{std::move(unit)}
    {}
};

using Resources = std::vector<Resource>;
using Options = std::vector<Option>;

/// The results from a query
struct QueryResults
{
    Options options;  // options used for results
    std::string message;
    std::string value;  // REVISIT maybe should be variant or similar with actual value?
};

/// Expected results from a query (for testing: checking that results match expectation)
struct Expectation
{
    ExpectationKind value_type;
    QueryStatus status;
    std::string value;
    Resources resources;
};

/// Verification query (model properties, etc)
struct Query
{
    std::string formula;
    std::string comment;
    Options options;
    Expectation expectation;
    // std::vector<QueryResults> results;
    std::string location;
};
using Queries = std::vector<Query>;

class Document;

class DocumentVisitor
{
public:
    virtual ~DocumentVisitor() noexcept = default;
    virtual void visit_doc_before(Document&) {}
    virtual void visit_doc_after(Document&) {}
    virtual void visit_variable(Variable&) {}
    virtual bool visit_template_before(Template&) { return true; }
    virtual void visit_template_after(Template&) {}
    virtual void visit_location(Location&) {}
    virtual void visit_edge(Edge&) {}
    virtual void visit_instance(Instance&) {}
    virtual void visit_process(Instance&) {}
    virtual void visit_function(Function&) {}
    virtual void visit_typedef(Symbol&) {}
    virtual void visit_io_decl(IODecl&) {}
    virtual void visit_progress(Progress&) {}
    virtual void visit_gantt(GanttEntry&) {}
    virtual void visit_instance_line(LSCInstanceLine&) {}
    virtual void visit_message(LSCMessage&) {}
    virtual void visit_condition(LSCCondition&) {}
    virtual void visit_update(LSCUpdate&) {}
};

class Document
{
public:
    Document();
    Document(const Document&) = delete;
    Document& operator=(const Document&) = delete;
    Document(Document&&) noexcept = default;
    Document& operator=(Document&&) noexcept = default;

    /// Returns the global declarations of the document.
    Declarations& get_globals() { return global; }

    /// Returns the templates of the document.
    const std::list<Template>& get_templates() const { return templates; }
    std::list<Template>& get_templates() { return templates; }
    const Template* find_template(std::string_view name) const;
    std::vector<Template*>& get_dynamic_templates();
    Template* find_dynamic_template(std::string_view name);

    /// Returns the processes of the document.
    std::list<Instance>& get_processes() { return processes; }

    Options& get_options();
    void set_options(const Options& options);

    /// Returns the queries enclosed in the model.
    const Queries& get_queries() const { return queries; }

    void add_position(uint32_t position, uint32_t offset, uint32_t line, std::shared_ptr<std::string> path);
    const PositionIndex::Line& find_position(uint32_t position) const;

    Variable* add_variable_to_function(Function*, Frame, Type, std::string_view, Expression initital, position_t);
    Variable* add_variable(Declarations*, Type type, std::string_view name, Expression initial, position_t);
    void add_progress_measure(Declarations*, Expression guard, Expression measure);

    Template& add_template(std::string_view name, const Frame& params, position_t, bool isTA = true,
                           std::string_view type = "", std::string_view mode = "");
    Template& add_dynamic_template(std::string_view name, const Frame& params, position_t pos);

    Instance& add_instance(std::string_view name, Instance& instance, Frame params,
                           const std::vector<Expression>& arguments, position_t);

    Instance& add_LSC_instance(std::string_view name, Instance& instance, Frame params,
                               const std::vector<Expression>& arguments, position_t);
    void remove_process(Instance& instance);  // LSC

    void copy_variables_from_to(const Template* from, Template* to) const;
    void copy_functions_from_to(const Template* from, Template* to) const;

    std::string obsTA;  // name of the observer TA instance

    void add_process(Instance& instance, position_t);
    void add_gantt(Declarations*, GanttEntry);  // copies GanttEntry and moves it
    void accept(DocumentVisitor&);

    void set_before_update(Expression e) { before_update = std::move(e); }
    Expression& get_before_update() { return before_update; }
    void set_after_update(Expression e) { after_update = std::move(e); }
    Expression& get_after_update() { return after_update; }

    void add_query(Query query);  // creates a copy and moves it
    bool queries_empty() const;

    /* The default priority for channels is also used for 'tau
     * transitions' (i.e. non-synchronizing transitions).
     */
    void begin_chan_priority(Expression chan);
    void add_chan_priority(char separator, Expression chan);
    const std::list<ChanPriority>& get_chan_priorities() const { return chan_priorities; }
    std::list<ChanPriority>& get_chan_priorities() { return chan_priorities; }

    /// Sets process priority for process \a name. */
    void set_proc_priority(std::string_view name, int priority);

    /// Returns process priority for process \a name. */
    int get_proc_priority(std::string_view name) const;

    /// Returns true if document has some priority declaration. */
    bool has_priority_declaration() const { return has_priorities; }

    /// Returns true if document has some strict invariant. */
    bool has_strict_invariants() const { return has_strict_inv; }

    /// Record that the document has some strict invariant. */
    void record_strict_invariant() { has_strict_inv = true; }

    /// Returns true if the document stops any clock. */
    bool has_stop_watch() const { return stops_clock; }

    /// Record that the document stops a clock. */
    void record_stop_watch() { stops_clock = true; }

    /// Returns true if the document has guards on controllable edges with strict lower bounds. */
    bool has_strict_lower_bound_on_controllable_edges() const { return has_strict_low_controlled_guards; }

    /// Record that the document has guards on controllable edges with strict lower bounds. */
    void record_strict_lower_bound_on_controllable_edges() { has_strict_low_controlled_guards = true; }

    void clock_guard_recv_broadcast() { has_guard_on_recv_broadcast = true; }
    bool has_clock_guard_recv_broadcast() const { return has_guard_on_recv_broadcast; }
    void set_sync_used(int s) { syncUsed = s; }
    int get_sync_used() const { return syncUsed; }

    void set_urgent_transition() { has_urgent_trans = true; }
    bool has_urgent_transition() const { return has_urgent_trans; }
    bool has_dynamic_templates() const { return !dyn_templates.empty(); }

    StringIndex add_string(std::string&& str) { return strings.add_string_if_new(std::move(str)); }
    const std::vector<std::string>& get_strings() const { return strings.get_strings(); };

protected:
    bool has_urgent_trans{false};
    bool has_priorities{false};
    bool has_strict_inv{false};
    bool stops_clock{false};
    bool has_strict_low_controlled_guards{false};
    bool has_guard_on_recv_broadcast{false};
    bool has_non_broadcast_chan{false};
    int default_chan_priority{0};
    std::list<ChanPriority> chan_priorities;
    std::map<std::string, int, std::less<>> proc_priority;
    int syncUsed{0};  // see typechecker

    // The list of templates.
    std::list<Template> templates;
    // List of dynamic templates
    std::list<Template> dyn_templates;
    std::vector<Template*> dyn_templates_vec;

    // The list of template instances.
    std::list<Instance> instances;

    std::list<Instance> lsc_instances;
    bool modified{false};

    // List of processes.
    std::list<Instance> processes;

    // Global declarations
    Declarations global;

    Expression before_update;
    Expression after_update;
    Options model_options;
    Queries queries;

    Variable* add_variable(std::list<Variable>& variables, Frame frame, Type type, std::string_view, position_t);

    std::string location;
    std::vector<Library> libraries;
    InternedStrings strings;
    SupportedMethods supported_methods{};

public:
    void add(Library&& lib);
    /// Returns the last successfully loaded library, or throws std::runtime_error.
    Library& last_library();
    void add_error(position_t, std::string msg, std::string ctx = "");
    void add_warning(position_t, std::string msg, std::string ctx = "");
    bool has_errors() const { return !errors.empty(); }
    bool has_warnings() const { return !warnings.empty(); }
    const std::vector<Error>& get_errors() const { return errors; }
    const std::vector<Error>& get_warnings() const { return warnings; }
    void clear_errors() const { errors.clear(); }
    void clear_warnings() const { warnings.clear(); }
    bool is_modified() const { return modified; }
    void set_modified(bool mod) { modified = mod; }
    IODecl* add_io_decl();
    void set_supported_methods(const SupportedMethods& supportedMethods);
    const SupportedMethods& get_supported_methods() const { return supported_methods; }
    const PositionIndex& get_positions() const { return positions; }
    void add_channel(bool is_broadcast);
    bool all_broadcast() const { return !has_non_broadcast_chan; }

private:
    // TODO: move errors & warnings to ParserBuilder to get rid of mutable
    mutable std::vector<Error> errors;
    mutable std::vector<Error> warnings;
    PositionIndex positions;
};
}  // namespace UTAP

#endif /* UTAP_DOCUMENT_HH */
